---
title: 'AI Agents'
description: 'Build autonomous AI systems that can reason, plan, and take action'
order: 6
duration: '8-10 hours'
---

# AI Agents

Chatbots answer questions. Agents get things done.

An agent can research a topic across dozens of sources, write a report, and email it to your team—all while you're in a meeting. This track teaches you to build autonomous systems that work independently on complex, multi-step tasks.

<Diagram title="The Agent Difference" type="flowchart" caption="Chatbots wait for you. Agents work for you.">
{`flowchart LR
    subgraph chatbot["Chatbot"]
        A1[You ask] --> A2[It answers]
        A2 --> A3[You ask again]
    end

    subgraph agent["Agent"]
        B1[You set goal] --> B2[It plans]
        B2 --> B3[It acts]
        B3 --> B4[It adapts]
        B4 --> B5[Goal achieved]
    end
`}
</Diagram>

<Callout type="info" title="Before You Start">
This track assumes you've completed [Start Here](/start-here) and are comfortable with [Git & GitHub](/git-github). Agent concepts build on that foundation.
</Callout>

<Callout type="tip">
**Already built chatbots?** Great—you're halfway there. Agents add planning, tool use, and autonomy on top of what you already know.
</Callout>

---

## What Makes an Agent?

Every agent follows the same loop:

<Diagram title="The Agent Loop" type="flowchart">
{`flowchart TB
    A[Observe] --> B[Think]
    B --> C[Plan]
    C --> D[Act]
    D --> E[Reflect]
    E -->|Continue?| A
    E -->|Done| F[Return Result]
`}
</Diagram>

<InfoTable
  columns={[
    { key: 'phase', header: 'Phase' },
    { key: 'what', header: 'What Happens' },
    { key: 'example', header: 'Example' },
  ]}
  rows={[
    { phase: <strong>Observe</strong>, what: 'Gather context', example: "Read the user's question, check current data" },
    { phase: <strong>Think</strong>, what: 'Reason about the situation', example: '"I need to search for recent data first"' },
    { phase: <strong>Plan</strong>, what: 'Break into steps', example: 'Search → Read → Analyze → Write' },
    { phase: <strong>Act</strong>, what: 'Execute using tools', example: 'Call search API, read documents' },
    { phase: <strong>Reflect</strong>, what: 'Evaluate results', example: '"Do I have enough information?"' },
  ]}
/>

---

## Types of Agents

### Task-Specific Agents

Built for one job, done exceptionally well:

<InfoTable
  columns={[
    { key: 'agent', header: 'Agent' },
    { key: 'does', header: 'What It Does' },
    { key: 'tools', header: 'Tools It Uses' },
  ]}
  rows={[
    { agent: <strong>Code Reviewer</strong>, does: 'Analyzes PRs for bugs, security, style', tools: 'Read, Grep, Glob' },
    { agent: <strong>Research Agent</strong>, does: 'Gathers and synthesizes information', tools: 'Web search, Document reader' },
    { agent: <strong>Data Analyst</strong>, does: 'Queries databases, generates insights', tools: 'SQL, Python, Charts' },
    { agent: <strong>Support Agent</strong>, does: 'Handles tickets, searches knowledge base', tools: 'KB search, CRM' },
  ]}
/>

### General-Purpose Agents

Flexible assistants for varied tasks:

- **Personal Assistant**: Calendar, email, task management
- **Project Coordinator**: Track work, manage workflows
- **Problem Solver**: Open-ended analysis and recommendations

### Multi-Agent Systems

Multiple agents working together:

<Diagram title="Multi-Agent Patterns" type="flowchart">
{`flowchart TB
    subgraph collab["Collaborative"]
        C1[Researcher] --> C2[Writer]
        C2 --> C3[Editor]
    end

    subgraph hierarchy["Hierarchical"]
        H1[Manager] --> H2[Worker 1]
        H1 --> H3[Worker 2]
        H1 --> H4[Worker 3]
    end

    subgraph debate["Debate"]
        D1[Agent A] <--> D2[Agent B]
        D1 --> D3[Consensus]
        D2 --> D3
    end
`}
</Diagram>

---

## Sub-Agents: Divide and Conquer

Complex tasks need specialized workers. Sub-agents handle specific pieces of work with focused context and limited tools.

### Why Sub-Agents?

<InfoTable
  columns={[
    { key: 'benefit', header: 'Benefit' },
    { key: 'why', header: 'Why It Matters' },
  ]}
  rows={[
    { benefit: <strong>Context Isolation</strong>, why: 'Each sub-agent works with only relevant information—no overload' },
    { benefit: <strong>Parallelization</strong>, why: 'Run multiple sub-agents simultaneously' },
    { benefit: <strong>Tool Restrictions</strong>, why: 'Limit what each sub-agent can do for safety' },
    { benefit: <strong>Specialization</strong>, why: 'Each sub-agent has tailored prompts for its domain' },
  ]}
/>

### Built-in Sub-Agents

Claude Code includes ready-to-use sub-agents:

- **Plan Sub-Agent**: Dedicated planning with task breakdown
- **Explore Sub-Agent**: Fast, read-only codebase search

### Creating Custom Sub-Agents

Define sub-agents as markdown files in `.claude/agents/`:

```markdown
---
name: code-reviewer
description: Expert code review specialist for quality and security reviews.
tools: Read, Grep, Glob
---

You are a code review specialist. When reviewing code:

1. Identify security vulnerabilities (injection, auth issues)
2. Check for performance problems (N+1 queries, memory leaks)
3. Verify adherence to project coding standards
4. Suggest specific, actionable improvements

Be thorough but constructive. Explain *why* something is a problem.
```

### Common Tool Combinations

<InfoTable
  columns={[
    { key: 'type', header: 'Agent Type' },
    { key: 'tools', header: 'Tools' },
    { key: 'best', header: 'Best For' },
  ]}
  rows={[
    { type: 'Read-only', tools: 'Read, Grep, Glob', best: 'Analysis, review, research' },
    { type: 'Test runner', tools: 'Bash, Read, Grep', best: 'Test execution, CI tasks' },
    { type: 'Code modifier', tools: 'Read, Edit, Write, Grep, Glob', best: 'Refactoring, generation' },
  ]}
/>

---

## Tools: The Agent's Hands

Agents need tools to interact with the world. Without tools, they can only talk. With tools, they can *do*.

<Diagram title="Tool Categories" type="flowchart">
{`flowchart TB
    subgraph info["Information"]
        I1[Web search]
        I2[Document reader]
        I3[API calls]
    end

    subgraph compute["Computation"]
        C1[Code execution]
        C2[Data analysis]
        C3[Calculations]
    end

    subgraph action["Action"]
        A1[File operations]
        A2[Send messages]
        A3[System commands]
    end
`}
</Diagram>

### Designing Good Tools

**Clear purpose**: Each tool does one thing well
```python
# Good: specific
"search_company_docs" - searches internal documentation

# Bad: vague
"search" - search what? where?
```

**Defined inputs**: Specific parameters with types
```python
{
    "name": "search_docs",
    "input_schema": {
        "properties": {
            "query": {"type": "string", "description": "Search terms"},
            "category": {"type": "string", "enum": ["policies", "products"]}
        }
    }
}
```

**Predictable outputs**: Consistent return format so the agent can parse results reliably.

---

## Memory: The Agent's Mind

Agents need memory to maintain context across steps and conversations.

### Short-term Memory

- Current conversation
- Working notes
- Intermediate results

### Long-term Memory

- Past interactions
- Learned preferences
- Domain knowledge

### Memory Strategies

<InfoTable
  columns={[
    { key: 'strategy', header: 'Strategy' },
    { key: 'best', header: 'Best For' },
    { key: 'how', header: 'How It Works' },
  ]}
  rows={[
    { strategy: 'RAG', best: 'Knowledge bases', how: 'Search stored documents' },
    { strategy: 'Summarization', best: 'Long conversations', how: 'Compress old context' },
    { strategy: 'Key-value store', best: 'Facts and preferences', how: 'Quick lookup' },
    { strategy: 'Vector database', best: 'Semantic search', how: 'Find similar past content' },
  ]}
/>

---

## Track Modules

<Steps>
<Step title="Building Agents">

Learn to build agents from scratch using the Claude API.

**You'll learn:**
- Agent architecture patterns
- Tool implementation
- State management
- Error handling and recovery

[Start Building →](./building-agents)

</Step>
<Step title="Using Agents">

Master prompting and get reliable results from any agent.

**You'll learn:**
- Writing effective system prompts
- Tool selection strategies
- Debugging agent behavior
- Advanced patterns (chain of thought, self-critique)

[Start Using →](./using-agents)

</Step>
<Step title="Agent Products">

Ship production-ready agent systems that users pay for.

**You'll learn:**
- Product architecture
- User experience design
- Deployment and scaling
- Monetization models

[Start Shipping →](./agent-products)

</Step>
<Step title="Multi-Agent Architectures">

Orchestrate multiple agents for parallel work and specialized tasks.

**You'll learn:**
- Custom subagents with isolated context and restricted tools
- Agent Teams & Swarms for parallel, peer-to-peer orchestration
- When to use subagents vs. teams vs. a single agent
- Practical patterns for code review, full-stack features, and migrations

[Start Orchestrating →](./multi-agent-architectures)

</Step>
</Steps>

---

## Quick Start Example

Here's a minimal research agent:

```python
from anthropic import Anthropic

client = Anthropic()

def research_agent(question: str) -> str:
    """Agent that researches a question using web search."""

    tools = [{
        "name": "web_search",
        "description": "Search the web for information",
        "input_schema": {
            "type": "object",
            "properties": {
                "query": {"type": "string"}
            },
            "required": ["query"]
        }
    }]

    messages = [{
        "role": "user",
        "content": f"""Research this question: {question}

        Use web_search to find information.
        Cite your sources in the final answer."""
    }]

    # Agent loop
    while True:
        response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=4096,
            tools=tools,
            messages=messages
        )

        if response.stop_reason == "tool_use":
            # Execute tools, add results, continue
            tool_results = execute_tools(response.content)
            messages.append({"role": "assistant", "content": response.content})
            messages.append({"role": "user", "content": tool_results})
        else:
            # Done - extract final text
            return extract_text(response.content)
```

---

## Best Practices

### Start Simple

<Diagram title="Agent Evolution" type="flowchart">
{`flowchart LR
    A[Single tool] --> B[Multiple tools]
    B --> C[Memory]
    C --> D[Sub-agents]
    D --> E[Multi-agent]
`}
</Diagram>

1. **One task, one tool**: Get that working first
2. **Add tools gradually**: One capability at a time
3. **Add memory when needed**: Not before
4. **Split into sub-agents**: When context gets too complex

### Common Pitfalls

<InfoTable
  columns={[
    { key: 'problem', header: 'Problem' },
    { key: 'symptom', header: 'Symptom' },
    { key: 'fix', header: 'Fix' },
  ]}
  rows={[
    { problem: 'Infinite loops', symptom: 'Same action repeated', fix: 'Detect loops, add exit conditions' },
    { problem: 'Tool misuse', symptom: 'Wrong tool for task', fix: 'Better tool descriptions' },
    { problem: 'Context overflow', symptom: 'Degraded performance', fix: 'Summarize, use sub-agents' },
    { problem: 'Hallucination', symptom: 'Made-up tool results', fix: 'Validate results, require citations' },
    { problem: 'Cost explosion', symptom: 'Huge API bills', fix: 'Token budgets, caching' },
  ]}
/>

### Safety First

- **Human approval** for sensitive actions (delete, send, pay)
- **Rate limits** and cost caps
- **Logging** all agent actions
- **Sandboxed environments** for testing
- **Clear boundaries** on what agents can/cannot do

---

## Real-World Applications

<InfoGrid columns={2}>
  <InfoCard
    title="Software"
    description="Code review, bug triage, doc generation, test creation"
  />
  <InfoCard
    title="Support"
    description="Ticket routing, knowledge search, escalation, follow-up"
  />
  <InfoCard
    title="Analysis"
    description="Report generation, anomaly detection, trend analysis"
  />
  <InfoCard
    title="Content"
    description="Drafting, social scheduling, email campaigns, translation"
  />
</InfoGrid>

---

## Resources

- [Claude Agent SDK](https://docs.anthropic.com/en/docs/agents) — Official documentation
- [Building Effective Agents](https://www.anthropic.com/research/building-effective-agents) — Anthropic research
- [Tool Use Guide](https://docs.anthropic.com/en/docs/tool-use) — API reference
- [Anthropic Cookbook](https://github.com/anthropics/anthropic-cookbook) — Example implementations

---

## Prerequisites

Before starting this track:

<Checklist>
  <ChecklistItem>Completed [Start Here](/start-here) track</ChecklistItem>
  <ChecklistItem>Basic Python knowledge</ChecklistItem>
  <ChecklistItem>Familiarity with APIs (REST, HTTP)</ChecklistItem>
  <ChecklistItem>Understanding of LLMs (Claude, ChatGPT)</ChecklistItem>
</Checklist>

---

<Callout type="tip" title="Supercharge Your Agents with MCP">
Agents become far more powerful when connected to real data sources. Learn how to connect Claude to databases, APIs, and external tools in the [MCP Integration track](/mcp).
</Callout>

<Callout type="success">
**Ready to build intelligent systems?** Start with [Building Agents](./building-agents) to create your first agent from scratch.
</Callout>
