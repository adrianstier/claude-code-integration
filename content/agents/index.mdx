---
title: 'AI Agents'
description: 'Build autonomous AI systems that can reason, plan, and take action'
order: 6
duration: '8-10 hours'
---

# AI Agents

Chatbots answer questions. Agents get things done.

An agent can research a topic across dozens of sources, write a report, and email it to your team—all while you're in a meeting. This track teaches you to build autonomous systems that work independently on complex, multi-step tasks.

<Diagram title="The Agent Difference" type="flowchart" caption="Chatbots wait for you. Agents work for you.">
{`flowchart LR
    subgraph chatbot["Chatbot"]
        A1[You ask] --> A2[It answers]
        A2 --> A3[You ask again]
    end

    subgraph agent["Agent"]
        B1[You set goal] --> B2[It plans]
        B2 --> B3[It acts]
        B3 --> B4[It adapts]
        B4 --> B5[Goal achieved]
    end
`}
</Diagram>

<Callout type="tip">
**Already built chatbots?** Great—you're halfway there. Agents add planning, tool use, and autonomy on top of what you already know.
</Callout>

---

## What Makes an Agent?

Every agent follows the same loop:

<Diagram title="The Agent Loop" type="flowchart">
{`flowchart TB
    A[Observe] --> B[Think]
    B --> C[Plan]
    C --> D[Act]
    D --> E[Reflect]
    E -->|Continue?| A
    E -->|Done| F[Return Result]
`}
</Diagram>

| Phase | What Happens | Example |
|-------|--------------|---------|
| **Observe** | Gather context | Read the user's question, check current data |
| **Think** | Reason about the situation | "I need to search for recent data first" |
| **Plan** | Break into steps | Search → Read → Analyze → Write |
| **Act** | Execute using tools | Call search API, read documents |
| **Reflect** | Evaluate results | "Do I have enough information?" |

---

## Types of Agents

### Task-Specific Agents

Built for one job, done exceptionally well:

| Agent | What It Does | Tools It Uses |
|-------|--------------|---------------|
| **Code Reviewer** | Analyzes PRs for bugs, security, style | Read, Grep, Glob |
| **Research Agent** | Gathers and synthesizes information | Web search, Document reader |
| **Data Analyst** | Queries databases, generates insights | SQL, Python, Charts |
| **Support Agent** | Handles tickets, searches knowledge base | KB search, CRM |

### General-Purpose Agents

Flexible assistants for varied tasks:

- **Personal Assistant**: Calendar, email, task management
- **Project Coordinator**: Track work, manage workflows
- **Problem Solver**: Open-ended analysis and recommendations

### Multi-Agent Systems

Multiple agents working together:

<Diagram title="Multi-Agent Patterns" type="flowchart">
{`flowchart TB
    subgraph collab["Collaborative"]
        C1[Researcher] --> C2[Writer]
        C2 --> C3[Editor]
    end

    subgraph hierarchy["Hierarchical"]
        H1[Manager] --> H2[Worker 1]
        H1 --> H3[Worker 2]
        H1 --> H4[Worker 3]
    end

    subgraph debate["Debate"]
        D1[Agent A] <--> D2[Agent B]
        D1 --> D3[Consensus]
        D2 --> D3
    end
`}
</Diagram>

---

## Sub-Agents: Divide and Conquer

Complex tasks need specialized workers. Sub-agents handle specific pieces of work with focused context and limited tools.

### Why Sub-Agents?

| Benefit | Why It Matters |
|---------|----------------|
| **Context Isolation** | Each sub-agent works with only relevant information—no overload |
| **Parallelization** | Run multiple sub-agents simultaneously |
| **Tool Restrictions** | Limit what each sub-agent can do for safety |
| **Specialization** | Each sub-agent has tailored prompts for its domain |

### Built-in Sub-Agents

Claude Code includes ready-to-use sub-agents:

- **Plan Sub-Agent**: Dedicated planning with task breakdown
- **Explore Sub-Agent**: Fast, read-only codebase search

### Creating Custom Sub-Agents

Define sub-agents as markdown files in `.claude/agents/`:

```markdown
---
name: code-reviewer
description: Expert code review specialist for quality and security reviews.
tools: Read, Grep, Glob
---

You are a code review specialist. When reviewing code:

1. Identify security vulnerabilities (injection, auth issues)
2. Check for performance problems (N+1 queries, memory leaks)
3. Verify adherence to project coding standards
4. Suggest specific, actionable improvements

Be thorough but constructive. Explain *why* something is a problem.
```

### Common Tool Combinations

| Agent Type | Tools | Best For |
|------------|-------|----------|
| Read-only | `Read, Grep, Glob` | Analysis, review, research |
| Test runner | `Bash, Read, Grep` | Test execution, CI tasks |
| Code modifier | `Read, Edit, Write, Grep, Glob` | Refactoring, generation |

---

## Tools: The Agent's Hands

Agents need tools to interact with the world. Without tools, they can only talk. With tools, they can *do*.

<Diagram title="Tool Categories" type="flowchart">
{`flowchart TB
    subgraph info["Information"]
        I1[Web search]
        I2[Document reader]
        I3[API calls]
    end

    subgraph compute["Computation"]
        C1[Code execution]
        C2[Data analysis]
        C3[Calculations]
    end

    subgraph action["Action"]
        A1[File operations]
        A2[Send messages]
        A3[System commands]
    end
`}
</Diagram>

### Designing Good Tools

**Clear purpose**: Each tool does one thing well
```python
# Good: specific
"search_company_docs" - searches internal documentation

# Bad: vague
"search" - search what? where?
```

**Defined inputs**: Specific parameters with types
```python
{
    "name": "search_docs",
    "input_schema": {
        "properties": {
            "query": {"type": "string", "description": "Search terms"},
            "category": {"type": "string", "enum": ["policies", "products"]}
        }
    }
}
```

**Predictable outputs**: Consistent return format so the agent can parse results reliably.

---

## Memory: The Agent's Mind

Agents need memory to maintain context across steps and conversations.

### Short-term Memory

- Current conversation
- Working notes
- Intermediate results

### Long-term Memory

- Past interactions
- Learned preferences
- Domain knowledge

### Memory Strategies

| Strategy | Best For | How It Works |
|----------|----------|--------------|
| RAG | Knowledge bases | Search stored documents |
| Summarization | Long conversations | Compress old context |
| Key-value store | Facts and preferences | Quick lookup |
| Vector database | Semantic search | Find similar past content |

---

## Track Modules

<Steps>
<Step title="Building Agents">

Learn to build agents from scratch using the Claude API.

**You'll learn:**
- Agent architecture patterns
- Tool implementation
- State management
- Error handling and recovery

[Start Building →](./building-agents)

</Step>
<Step title="Using Agents">

Master prompting and get reliable results from any agent.

**You'll learn:**
- Writing effective system prompts
- Tool selection strategies
- Debugging agent behavior
- Advanced patterns (chain of thought, self-critique)

[Start Using →](./using-agents)

</Step>
<Step title="Agent Products">

Ship production-ready agent systems that users pay for.

**You'll learn:**
- Product architecture
- User experience design
- Deployment and scaling
- Monetization models

[Start Shipping →](./agent-products)

</Step>
</Steps>

---

## Quick Start Example

Here's a minimal research agent:

```python
from anthropic import Anthropic

client = Anthropic()

def research_agent(question: str) -> str:
    """Agent that researches a question using web search."""

    tools = [{
        "name": "web_search",
        "description": "Search the web for information",
        "input_schema": {
            "type": "object",
            "properties": {
                "query": {"type": "string"}
            },
            "required": ["query"]
        }
    }]

    messages = [{
        "role": "user",
        "content": f"""Research this question: {question}

        Use web_search to find information.
        Cite your sources in the final answer."""
    }]

    # Agent loop
    while True:
        response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=4096,
            tools=tools,
            messages=messages
        )

        if response.stop_reason == "tool_use":
            # Execute tools, add results, continue
            tool_results = execute_tools(response.content)
            messages.append({"role": "assistant", "content": response.content})
            messages.append({"role": "user", "content": tool_results})
        else:
            # Done - extract final text
            return extract_text(response.content)
```

---

## Best Practices

### Start Simple

<Diagram title="Agent Evolution" type="flowchart">
{`flowchart LR
    A[Single tool] --> B[Multiple tools]
    B --> C[Memory]
    C --> D[Sub-agents]
    D --> E[Multi-agent]
`}
</Diagram>

1. **One task, one tool**: Get that working first
2. **Add tools gradually**: One capability at a time
3. **Add memory when needed**: Not before
4. **Split into sub-agents**: When context gets too complex

### Common Pitfalls

| Problem | Symptom | Fix |
|---------|---------|-----|
| Infinite loops | Same action repeated | Detect loops, add exit conditions |
| Tool misuse | Wrong tool for task | Better tool descriptions |
| Context overflow | Degraded performance | Summarize, use sub-agents |
| Hallucination | Made-up tool results | Validate results, require citations |
| Cost explosion | Huge API bills | Token budgets, caching |

### Safety First

- **Human approval** for sensitive actions (delete, send, pay)
- **Rate limits** and cost caps
- **Logging** all agent actions
- **Sandboxed environments** for testing
- **Clear boundaries** on what agents can/cannot do

---

## Real-World Applications

| Domain | Use Cases |
|--------|-----------|
| **Software** | Code review, bug triage, doc generation, test creation |
| **Support** | Ticket routing, knowledge search, escalation, follow-up |
| **Analysis** | Report generation, anomaly detection, trend analysis |
| **Content** | Drafting, social scheduling, email campaigns, translation |

---

## Resources

- [Claude Agent SDK](https://docs.anthropic.com/en/docs/agents) — Official documentation
- [Building Effective Agents](https://www.anthropic.com/research/building-effective-agents) — Anthropic research
- [Tool Use Guide](https://docs.anthropic.com/en/docs/tool-use) — API reference
- [Anthropic Cookbook](https://github.com/anthropics/anthropic-cookbook) — Example implementations

---

## Prerequisites

Before starting this track:

<Checklist>
  <ChecklistItem>Completed [Start Here](/start-here) track</ChecklistItem>
  <ChecklistItem>Basic Python knowledge</ChecklistItem>
  <ChecklistItem>Familiarity with APIs (REST, HTTP)</ChecklistItem>
  <ChecklistItem>Understanding of LLMs (Claude, ChatGPT)</ChecklistItem>
</Checklist>

---

<Callout type="success">
**Ready to build intelligent systems?** Start with [Building Agents](./building-agents) to create your first agent from scratch.
</Callout>
